<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: sans-serif;
            display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw;
        }
        canvas { display: block; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        #status {
            position: absolute; bottom: 10px; left: 10px; 
            background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 4px;
            font-size: 12px; pointer-events: none; z-index: 10;
        }
    </style>
</head>
<body>
    <div id="status">Waiting for config...</div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "fflate": "https://unpkg.com/fflate@0.8.2/esm/browser.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        let scene, camera, renderer, figureGroup, ground, gridHelper, envGroup;
        let ambientLight, dirLight;
        let mixer; 
        let clock = new THREE.Clock(); 
        let config = {}; 
        let isPreviewing = false;
        let isRendering = false;
        let previewReqId;

        // --- 动作重定向变量 ---
        let smplSkeletonRoot = null; // 虚拟 SMPL 骨架（不可见，用于跑动画数据）
        let smplMixer = null;
        let boneMap = {}; // GLB骨骼 -> SMPL骨骼的映射
        let globalInverseScale = 1.0; // 关键：反向缩放因子
        
        const SKYBOX_PATH = "./textures/skybox/"; 
        const baseFigureHeadRadius = 0.25;
        const baseFigureBodyHeight = 0.7; 

        // SMPL 骨骼定义
        const SMPL_PARENTS = [-1, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 9, 12, 13, 14, 16, 17, 18, 19, 20, 21];
        const SMPL_JOINT_NAMES = [
            'Pelvis', 'L_Hip', 'R_Hip', 'Spine1', 'L_Knee', 'R_Knee', 'Spine2', 'L_Ankle', 'R_Ankle', 'Spine3', 
            'L_Foot', 'R_Foot', 'Neck', 'L_Collar', 'R_Collar', 'Head', 'L_Shoulder', 'R_Shoulder', 
            'L_Elbow', 'R_Elbow', 'L_Wrist', 'R_Wrist', 'L_Hand', 'R_Hand'
        ];
        // 虚拟骨骼的初始偏移（近似值）
        const SMPL_OFFSETS = [
             [0,0,0], [0.06, -0.06, 0.02], [-0.06, -0.06, 0.02], [0, 0.1, -0.02],
             [0.05, -0.37, 0], [-0.05, -0.37, 0], [0, 0.12, 0],
             [0, -0.4, 0], [0, -0.4, 0], [0, 0.11, 0],
             [0, -0.07, 0.1], [0, -0.07, 0.1], [0, 0.12, -0.02],
             [0.08, 0.02, 0.02], [-0.08, 0.02, 0.02], [0, 0.1, 0.02],
             [0.11, -0.02, -0.02], [-0.11, -0.02, -0.02],
             [0.26, 0, 0], [-0.26, 0, 0],
             [0.24, 0, 0], [-0.24, 0, 0],
             [0.08, 0, 0], [-0.08, 0, 0]
        ];

        // 骨骼名称映射表 (SMPL -> Mixamo/GLB)
        // 核心修复：根据您的 Blender 截图，精确匹配该模型的骨骼名称
        // 我们将截图中的名称放在数组的第一个位置 (优先级最高)
        const BONE_MAP_QUERY = {
            // 根骨骼
            'Pelvis': ['Pelvis', 'Hips', 'Hip', 'Root', 'mixamorig:Hips'],
            
            // 腿部 (截图显示为 L_Hip, R_Hip, L_Knee, R_Knee 等)
            'L_Hip':  ['L_Hip', 'LeftUpLeg', 'Left_Hip', 'mixamorig:LeftUpLeg'],
            'R_Hip':  ['R_Hip', 'RightUpLeg', 'Right_Hip', 'mixamorig:RightUpLeg'],
            'L_Knee': ['L_Knee', 'LeftLeg', 'Left_Knee', 'mixamorig:LeftLeg'],
            'R_Knee': ['R_Knee', 'RightLeg', 'Right_Knee', 'mixamorig:RightLeg'],
            'L_Ankle':['L_Ankle', 'LeftFoot', 'Left_Ankle', 'mixamorig:LeftFoot'],
            'R_Ankle':['R_Ankle', 'RightFoot', 'Right_Ankle', 'mixamorig:RightFoot'],
            'L_Foot': ['L_Foot', 'LeftToeBase', 'Left_Foot', 'mixamorig:LeftToeBase'],
            'R_Foot': ['R_Foot', 'RightToeBase', 'Right_Foot', 'mixamorig:RightToeBase'],
            
            // 脊柱 (截图显示为 Spine1 -> Spine2 -> Spine3)
            // 注意：SMPL 的 Spine1 对应模型 Spine1，SMPL Spine2 对应模型 Spine2
            'Spine1': ['Spine1', 'Spine', 'Spine_01', 'mixamorig:Spine'],
            'Spine2': ['Spine2', 'Spine1', 'Spine_02', 'mixamorig:Spine1'],
            'Spine3': ['Spine3', 'Spine2', 'Chest', 'mixamorig:Spine2'],
            
            // 颈部与头部
            'Neck':   ['Neck', 'Head_Neck', 'mixamorig:Neck'],
            'Head':   ['Head', 'mixamorig:Head'],
            
            // 手臂与肩膀 (截图显示为 L_Collar -> L_Shoulder -> L_Elbow -> L_Wrist)
            'L_Collar':['L_Collar', 'LeftShoulder', 'L_Clavicle', 'mixamorig:LeftShoulder'],
            'R_Collar':['R_Collar', 'RightShoulder', 'R_Clavicle', 'mixamorig:RightShoulder'],
            
            // 注意：截图中的 L_Shoulder 对应的是大臂(Upper Arm)，SMPL中也叫 L_Shoulder
            'L_Shoulder':['L_Shoulder', 'LeftArm', 'L_Arm', 'mixamorig:LeftArm'],
            'R_Shoulder':['R_Shoulder', 'RightArm', 'R_Arm', 'mixamorig:RightArm'],
            
            'L_Elbow':['L_Elbow', 'LeftForeArm', 'mixamorig:LeftForeArm'],
            'R_Elbow':['R_Elbow', 'RightForeArm', 'mixamorig:RightForeArm'],
            
            'L_Wrist':['L_Wrist', 'LeftHand', 'L_Hand', 'mixamorig:LeftHand'],
            'R_Wrist':['R_Wrist', 'RightHand', 'R_Hand', 'mixamorig:RightHand'],
            
            // 手掌 (截图未展开，通常在 Wrist 之下，SMPL 中叫 Hand)
            'L_Hand': ['L_Hand', 'LeftHandIndex1', 'mixamorig:LeftHandIndex1'], 
            'R_Hand': ['R_Hand', 'RightHandIndex1', 'mixamorig:RightHandIndex1']
        };
        
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        const EasingFunctions = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (--t) * t * t + 1,
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
        };
        const lerp = (a, b, t) => a * (1 - t) + b * t;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.useLegacyLights = false; 
            document.body.appendChild(renderer.domElement);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(10, 30, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            dirLight.shadow.bias = -0.0005;
            scene.add(dirLight);

            ground = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            gridHelper = new THREE.GridHelper(200, 100, 0x000000, 0x404040);
            gridHelper.position.y = 0.01;
            gridHelper.material.opacity = 0.5;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            envGroup = new THREE.Group();
            scene.add(envGroup);

            regenerateEnvironment(12345);
            
            // 初始化虚拟骨架
            createVirtualSMPLSkeleton();

            window.addEventListener('resize', onWindowResize, false);
            onWindowResize();
            renderer.render(scene, camera);
        }

        // 创建不可见的标准 SMPL 骨架，用于接收 HY-Motion 数据
        function createVirtualSMPLSkeleton() {
            if(smplSkeletonRoot) scene.remove(smplSkeletonRoot);
            const bones = [];
            for(let i=0; i<24; i++) {
                const bone = new THREE.Bone();
                bone.name = "SMPL_" + SMPL_JOINT_NAMES[i];
                bones.push(bone);
            }
            for(let i=0; i<24; i++) {
                const parentIdx = SMPL_PARENTS[i];
                if(parentIdx === -1) {
                    smplSkeletonRoot = bones[i];
                } else {
                    bones[parentIdx].add(bones[i]);
                    const offset = SMPL_OFFSETS[i] || [0,0,0];
                    bones[i].position.set(offset[0], offset[1], offset[2]);
                }
            }
            // 隐藏虚拟骨架
            smplSkeletonRoot.visible = false;
            scene.add(smplSkeletonRoot);
        }

        function onWindowResize() {
            if (isRendering) return;
            let targetAspect = window.innerWidth / window.innerHeight;
            if (config.width && config.height) {
                targetAspect = config.width / config.height;
            }
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const windowAspect = windowWidth / windowHeight;
            let finalWidth, finalHeight;
            if (windowAspect > targetAspect) {
                finalHeight = windowHeight;
                finalWidth = finalHeight * targetAspect;
            } else {
                finalWidth = windowWidth;
                finalHeight = finalWidth / targetAspect;
            }
            camera.aspect = targetAspect; 
            camera.updateProjectionMatrix();
            renderer.setSize(finalWidth, finalHeight);
        }

        function regenerateEnvironment(seed) {
            while(envGroup.children.length > 0){ 
                const obj = envGroup.children[0];
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) obj.material.dispose();
                envGroup.remove(obj); 
            }
            const rand = mulberry32(seed); 
            const distMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.9 });
            for (let i = 0; i < 40; i++) {
                const s = rand() * 5 + 2; 
                const angle = rand() * Math.PI * 2;
                const dist = 60 * (0.2 + rand() * 0.8); 
                const box = new THREE.Mesh(new THREE.BoxGeometry(s, s, s), distMat);
                box.position.set(Math.cos(angle) * dist, s / 2, Math.sin(angle) * dist);
                box.castShadow = true;
                box.receiveShadow = true;
                envGroup.add(box);
            }
            const pillarGeo = new THREE.BoxGeometry(1, 10, 1);
            const pillarMat = new THREE.MeshStandardMaterial({color: 0xff5555});
            [[-15, -15], [15, 15], [-15, 15], [15, -15]].forEach(pos => {
                const p = new THREE.Mesh(pillarGeo, pillarMat);
                p.position.set(pos[0], 5, pos[1]);
                p.castShadow = true;
                p.receiveShadow = true;
                envGroup.add(p);
            });
        }

        function setupEnvironment(cfg) {
            const type = cfg.skyboxType || "None (Gray)";
            gridHelper.visible = true; 
            if (type === "Texture Skybox (Folder)") {
                const loader = new THREE.CubeTextureLoader();
                loader.setPath(SKYBOX_PATH);
                loader.load(
                    ['px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'],
                    (texture) => {
                        scene.background = texture;
                        scene.environment = texture;
                        scene.fog = null;
                        document.getElementById('status').innerText = "Skybox loaded.";
                        renderer.render(scene, camera);
                    },
                    undefined,
                    () => { scene.background = new THREE.Color(0x444444); }
                );
            } else if (type === "Simple Sky (Blue)") {
                scene.background = new THREE.Color(0x87CEEB);
                scene.environment = null;
                scene.fog = new THREE.Fog(0x87CEEB, 20, 100);
            } else {
                scene.background = new THREE.Color(0x444444);
                scene.environment = null;
                scene.fog = null;
            }
        }

        // --- 1. 将 HY-Motion 数据应用到 虚拟SMPL骨架 上 ---
        function applyHyMotionData(hyData) {
            if (!hyData || !hyData.quaternions || !hyData.translations) return false;
            
            if (smplMixer) smplMixer.stopAllAction();
            smplMixer = new THREE.AnimationMixer(smplSkeletonRoot);

            const frames = hyData.frames;
            const joints = hyData.joints; 
            const fps = hyData.fps || 30;
            const tracks = [];
            const times = [];
            for (let i=0; i<frames; i++) times.push(i / fps);

            // 位移数据 (单位: 米)
            const rootTransValues = [];
            for (let i=0; i<frames; i++) {
                const idx = i * 3;
                rootTransValues.push(hyData.translations[idx], hyData.translations[idx+1], hyData.translations[idx+2]);
            }
            tracks.push(new THREE.VectorKeyframeTrack('SMPL_Pelvis.position', times, rootTransValues));

            // 旋转数据
            for (let j = 0; j < joints; j++) {
                const smplName = "SMPL_" + SMPL_JOINT_NAMES[j];
                const quatValues = [];
                for (let i=0; i<frames; i++) {
                    const offset = (i * joints + j) * 4;
                    quatValues.push(
                        hyData.quaternions[offset],
                        hyData.quaternions[offset+1],
                        hyData.quaternions[offset+2],
                        hyData.quaternions[offset+3]
                    );
                }
                tracks.push(new THREE.QuaternionKeyframeTrack(`${smplName}.quaternion`, times, quatValues));
            }

            if (tracks.length > 0) {
                const clip = new THREE.AnimationClip("HyMotionSMPL", -1, tracks);
                const action = smplMixer.clipAction(clip);
                action.play();
                console.log(`[ThreeJS] Applied HY-Motion to Virtual Skeleton.`);
                return true;
            }
            return false;
        }

        // --- 2. 预计算骨骼映射 ---
        function calculateRetargetOffsets(model) {
            boneMap = {};
            const modelBones = {};
            model.traverse(o => { if (o.isBone) modelBones[o.name] = o; });

            for (let i = 0; i < SMPL_JOINT_NAMES.length; i++) {
                const smplName = SMPL_JOINT_NAMES[i];
                const candidates = BONE_MAP_QUERY[smplName];
                if (candidates) {
                    for (const cand of candidates) {
                        const found = Object.keys(modelBones).find(name => name === cand) || 
                                      Object.keys(modelBones).find(name => name.includes(cand));
                        if (found) { 
                            boneMap[smplName] = modelBones[found];
                            break; 
                        }
                    }
                }
            }
        }

        // --- 3. 实时重定向 (每帧调用) ---
        function retargetSkeleton() {
            if (!smplSkeletonRoot) return;
            
            for (let i = 0; i < SMPL_JOINT_NAMES.length; i++) {
                const smplName = SMPL_JOINT_NAMES[i];
                const smplNode = smplSkeletonRoot.getObjectByName("SMPL_" + smplName);
                if (!smplNode) continue;
                
                let targetBone = boneMap[smplName];
                if (!targetBone) continue;

                // A. 旋转复制 (世界空间)
                const smplWorldQuat = new THREE.Quaternion();
                smplNode.getWorldQuaternion(smplWorldQuat);
                
                if (targetBone.parent) {
                    const parentWorldQuat = new THREE.Quaternion();
                    targetBone.parent.getWorldQuaternion(parentWorldQuat);
                    const parentInverse = parentWorldQuat.invert();
                    const localQuat = parentInverse.multiply(smplWorldQuat);
                    targetBone.quaternion.copy(localQuat);
                } else {
                    targetBone.quaternion.copy(smplWorldQuat);
                }

                // B. 位移复制 (仅针对 Root/Hips)
                // [关键修复] 必须乘以 inverseScale 才能在缩放后的世界中移动正确的距离
                if (smplName === 'Pelvis') {
                    const smplWorldPos = new THREE.Vector3();
                    smplNode.getWorldPosition(smplWorldPos);
                    
                    // 将 SMPL 的世界位移 (米) 转换为 目标骨骼的本地位移
                    // 假设 targetBone 的父级就是 figureGroup (或其缩放结构的一部分)
                    // localPos = worldPos / scale
                    targetBone.position.copy(smplWorldPos).multiplyScalar(globalInverseScale);
                }
            }
        }

        async function setupFigure(cfg, hyData = null) {
            if (figureGroup) scene.remove(figureGroup);
            figureGroup = new THREE.Group();
            scene.add(figureGroup);
            
            if (mixer) { mixer.stopAllAction(); mixer = null; }

            if (cfg.modelUrl && cfg.modelUrl.length > 5 && cfg.modelUrl !== "none") {
                document.getElementById('status').innerText = "Loading external model...";
                try {
                    let model;
                    let animations = [];
                    const urlLower = cfg.modelUrl.toLowerCase();
                    if (urlLower.endsWith('.fbx')) {
                        const loader = new FBXLoader();
                        model = await loader.loadAsync(cfg.modelUrl);
                        animations = model.animations;
                    } else {
                        const loader = new GLTFLoader();
                        const gltf = await loader.loadAsync(cfg.modelUrl);
                        model = gltf.scene;
                        animations = gltf.animations;
                    }
                    
                    model.position.set(0, 0, 0);
                    model.rotation.set(0, 0, 0);
                    model.scale.set(1, 1, 1);
                    model.updateMatrixWorld(true);

                    const box = new THREE.Box3().setFromObject(model);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    
                    const REFERENCE_HEIGHT = 1.8;
                    const rawHeight = size.y || 1.0; 
                    const normalizeScale = REFERENCE_HEIGHT / rawHeight;
                    const finalScale = normalizeScale * (cfg.scale || 1.0);
                    
                    // [关键] 计算反向缩放，用于位移修正
                    globalInverseScale = 1.0 / finalScale; 
                    
                    model.scale.setScalar(finalScale);
                    model.updateMatrixWorld(true);

                    const newBox = new THREE.Box3().setFromObject(model);
                    const center = new THREE.Vector3();
                    newBox.getCenter(center);

                    model.position.x = -center.x;
                    model.position.z = -center.z;
                    model.position.y = -newBox.min.y;

                    model.traverse(o => {
                        if (o.isMesh) {
                            o.castShadow = true;
                            o.receiveShadow = true;
                            if (o.material) {
                                o.material.side = THREE.DoubleSide;
                                if(o.material.shininess) o.material.shininess = 0;
                            }
                        }
                    });
                    
                    figureGroup.add(model);

                    let animApplied = false;
                    if (hyData) {
                        calculateRetargetOffsets(model); // 建立映射
                        animApplied = applyHyMotionData(hyData); // 跑虚拟骨骼动画
                    }

                    if (!animApplied && animations && animations.length > 0) {
                        mixer = new THREE.AnimationMixer(model);
                        const animIndex = Math.min(cfg.animIndex || 0, animations.length - 1);
                        const clip = animations[animIndex];
                        const action = mixer.clipAction(clip);
                        action.timeScale = (cfg.timeScale !== undefined) ? cfg.timeScale : 1.0;
                        action.play();
                    }

                    document.getElementById('status').innerText = "Model loaded.";
                    return; 
                } catch (e) {
                    console.error("Failed to load model", e);
                    document.getElementById('status').innerText = "Model load failed: " + e.message;
                }
            }
            createProceduralFigure(cfg);
        }

        function createProceduralFigure(cfg) {
            const scale = cfg.scale || 1.0;
            const limbLen = (cfg.limbLength || 0.6) * scale;
            const headR = baseFigureHeadRadius * scale;
            const bodyH = baseFigureBodyHeight * scale;
            const bodyW = 0.5 * scale;
            const bodyD = 0.25 * scale;
            const limbR = 0.08 * scale;
            const matYellow = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.5 });
            const matGreen = new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.6 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.6 });
            const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const legCenterY = limbLen / 2;
            const bodyCenterY = limbLen + bodyH / 2;
            const headCenterY = limbLen + bodyH + headR;
            const head = new THREE.Mesh(new THREE.SphereGeometry(headR, 32, 16), matYellow);
            head.position.y = headCenterY;
            head.castShadow = true;
            figureGroup.add(head);
            if (cfg.showFace) {
                const eyeGeo = new THREE.SphereGeometry(headR * 0.15, 8, 8);
                const leftEye = new THREE.Mesh(eyeGeo, matBlack);
                leftEye.position.set(-headR*0.35, headR*0.15, headR*0.85);
                head.add(leftEye);
                const rightEye = leftEye.clone();
                rightEye.position.x = -leftEye.position.x;
                head.add(rightEye);
                const mouth = new THREE.Mesh(new THREE.BoxGeometry(headR*0.5, headR*0.1, headR*0.1), matBlack);
                mouth.position.set(0, -headR*0.3, headR*0.85);
                head.add(mouth);
            }
            const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyD), matGreen);
            body.position.y = bodyCenterY;
            body.castShadow = true;
            figureGroup.add(body);
            const limbGeo = new THREE.CylinderGeometry(limbR, limbR, limbLen, 12);
            const armY = bodyCenterY + bodyH/2 - limbR; 
            const armX = bodyW / 2 + limbR;
            const leftArm = new THREE.Mesh(limbGeo, matRed);
            leftArm.position.set(-armX, armY - limbLen/2, 0);
            leftArm.castShadow = true;
            figureGroup.add(leftArm);
            const rightArm = new THREE.Mesh(limbGeo, matRed);
            rightArm.position.set(armX, armY - limbLen/2, 0);
            rightArm.castShadow = true;
            figureGroup.add(rightArm);
            const legX = bodyW / 4;
            const leftLeg = new THREE.Mesh(limbGeo, matRed);
            leftLeg.position.set(-legX, legCenterY, 0);
            leftLeg.castShadow = true;
            figureGroup.add(leftLeg);
            const rightLeg = new THREE.Mesh(limbGeo, matRed);
            rightLeg.position.set(legX, legCenterY, 0);
            rightLeg.castShadow = true;
            figureGroup.add(rightLeg);
        }

        function calculateFrameState(frame, cfg) {
            let state = {
                figX: 0, figY: 0, figZ: 0, figRot: 0, 
                dist: cfg.initialDistance,
                elev: cfg.initialElevationDeg * (Math.PI / 180),
                azim: cfg.initialAzimuthDeg * (Math.PI / 180),
                panX: 0, panY: 0,
                fov: cfg.fov,
                roll: 0
            };
            const applySegments = (segments) => {
                if (!segments || segments.length === 0) return;
                const sorted = segments.slice().sort((a, b) => a.startFrame - b.startFrame);
                sorted.forEach(seg => {
                    let val = null;
                    if (frame >= seg.endFrame) { val = seg.endValue; } 
                    else if (frame >= seg.startFrame) {
                        const len = seg.endFrame - seg.startFrame;
                        const progress = len === 0 ? 1 : (frame - seg.startFrame) / len;
                        const fn = EasingFunctions[seg.easing] || EasingFunctions.linear;
                        const t = fn(progress);
                        val = lerp(seg.startValue, seg.endValue, t);
                    }
                    if (val !== null) {
                        switch (seg.type) {
                            case 'x_pos': state.figX = val; break;
                            case 'y_pos': state.figY = val; break;
                            case 'z_pos': state.figZ = val; break;
                            case 'rotation_y': state.figRot = val * (Math.PI / 180); break;
                            case 'distance': state.dist = val; break;
                            case 'panX': state.panX = val; break;
                            case 'panY': state.panY = val; break;
                            case 'fov': state.fov = val; break;
                            case 'elevation': state.elev = val * (Math.PI / 180); break;
                            case 'azimuth': state.azim = val * (Math.PI / 180); break;
                            case 'roll': state.roll = val * (Math.PI / 180); break;
                        }
                    }
                });
            };
            applySegments(cfg.figureSegments);
            applySegments(cfg.cameraSegments);
            return state;
        }

        function updateScene(state, cfg) {
            figureGroup.position.set(state.figX, state.figY, state.figZ);
            figureGroup.rotation.y = state.figRot;
            const followMode = cfg.cameraFollowMode || 'follow';
            const basePos = (followMode === 'follow') ? figureGroup.position.clone() : new THREE.Vector3(0, 0, 0);
            const defaultHeight = 1.0; 
            const lookAtTarget = new THREE.Vector3(
                basePos.x + state.panX,
                basePos.y + defaultHeight + (cfg.lookAtHeightOffset || 0) + state.panY,
                basePos.z
            );
            let elev = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, state.elev));
            let dist = Math.max(0.1, state.dist);
            const cx = lookAtTarget.x + dist * Math.cos(elev) * Math.sin(state.azim);
            const cy = lookAtTarget.y + dist * Math.sin(elev);
            const cz = lookAtTarget.z + dist * Math.cos(elev) * Math.cos(state.azim);
            camera.position.set(cx, cy, cz);
            if (camera.fov !== state.fov) {
                camera.fov = state.fov;
                camera.updateProjectionMatrix();
            }
            camera.up.set(0, 1, 0);
            camera.lookAt(lookAtTarget);
            if (state.roll !== 0) {
                const forward = new THREE.Vector3().subVectors(lookAtTarget, camera.position).normalize();
                camera.up.applyQuaternion(new THREE.Quaternion().setFromAxisAngle(forward, state.roll));
                camera.lookAt(lookAtTarget); 
            }
        }

        function extractHyMotionData(cfg) {
            if (cfg.figureSegments) {
                const hyAction = cfg.figureSegments.find(s => s.type === 'hymotion_clip');
                if (hyAction) return hyAction.data;
            }
            return null;
        }

        async function renderBatch(newConfig) {
            config = newConfig; 
            isRendering = true; 

            renderer.setSize(config.width, config.height);
            camera.aspect = config.width / config.height;
            camera.updateProjectionMatrix();

            const seed = config.seed !== undefined ? config.seed : Date.now();
            regenerateEnvironment(seed);
            setupEnvironment(config);
            const hyData = extractHyMotionData(config);
            await setupFigure(config, hyData);
            
            const statusEl = document.getElementById('status');
            statusEl.innerText = "Rendering...";

            const frames = [];
            const total = config.numFrames;
            const fps = config.fps || 30;
            const frameDuration = 1 / fps; 

            for (let i = 0; i < total; i++) {
                const state = calculateFrameState(i, config);
                updateScene(state, config);

                if (smplMixer) {
                    smplMixer.setTime(i * frameDuration);
                    retargetSkeleton(); // [关键] 每一帧都同步骨骼
                }
                else if (mixer) {
                    mixer.setTime(i * frameDuration);
                }

                renderer.render(scene, camera);
                const dataURL = renderer.domElement.toDataURL("image/png");
                frames.push(dataURL);
                
                if (i % 5 === 0) {
                    statusEl.innerText = `Rendering: ${i} / ${total}`;
                    await new Promise(r => setTimeout(r, 0));
                }
            }

            statusEl.innerText = "Uploading results...";
            window.parent.postMessage({
                type: "RENDER_RESULT",
                request_id: config.request_id,
                images: frames
            }, "*");
            statusEl.innerText = "Done. Preview Mode.";
            isRendering = false;
            onWindowResize();
        }

        function startPreviewLoop() {
            if (isPreviewing) { 
                isPreviewing = false;
                cancelAnimationFrame(previewReqId);
                document.getElementById('status').innerText = "Preview Stopped.";
                return;
            }
            if (!config.numFrames) {
                document.getElementById('status').innerText = "Run prompt first to load config.";
                return;
            }
            isPreviewing = true;
            isRendering = false;
            onWindowResize();

            const seed = config.seed !== undefined ? config.seed : 12345;
            regenerateEnvironment(seed);
            setupEnvironment(config);
            
            const hyData = extractHyMotionData(config);
            setupFigure(config, hyData);

            let frame = 0;
            const fps = config.fps || 30;
            const frameInterval = 1000 / fps;
            
            function loop() {
                if (!isPreviewing) return;
                
                const state = calculateFrameState(frame, config);
                updateScene(state, config);

                if (smplMixer) {
                    smplMixer.setTime(frame / fps);
                    retargetSkeleton(); // [关键] 预览时也同步
                } else if (mixer) {
                    mixer.setTime(frame / fps);
                }

                renderer.render(scene, camera);
                document.getElementById('status').innerText = `Preview Frame: ${frame}`;
                frame++;
                if (frame >= config.numFrames) frame = 0;
                
                setTimeout(() => {
                    previewReqId = requestAnimationFrame(loop);
                }, frameInterval);
            }
            clock.start(); 
            loop();
        }

        window.addEventListener('message', (event) => {
            const data = event.data;
            if (data.type === "RENDER_BATCH") {
                isPreviewing = false;
                cancelAnimationFrame(previewReqId);
                renderBatch(data.config);
            } else if (data.type === "START_PREVIEW") {
                if (data.config) config = data.config;
                startPreviewLoop(); 
            }
        });

        init();

    </script>
</body>
</html>