<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000;
            color: #fff; 
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }
        canvas { 
            display: block; 
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #status {
            position: absolute; bottom: 10px; left: 10px; 
            background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 4px;
            font-size: 12px; pointer-events: none; z-index: 10;
        }
    </style>
</head>
<body>
    <div id="status">Waiting for config...</div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "./libs/three.module.js",
                "three/addons/": "./libs/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let scene, camera, renderer, figureGroup, ground, gridHelper, envGroup;
        let ambientLight, dirLight;
        let config = {}; 
        let isPreviewing = false;
        let isRendering = false;
        let previewReqId;
        
        const SKYBOX_PATH = "./textures/skybox/"; 
        const baseFigureHeadRadius = 0.25;
        const baseFigureBodyHeight = 0.7; 
        
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        const EasingFunctions = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (--t) * t * t + 1,
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
        };
        const lerp = (a, b, t) => a * (1 - t) + b * t;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.useLegacyLights = false; 
            document.body.appendChild(renderer.domElement);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(10, 30, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -30;
            dirLight.shadow.camera.right = 30;
            dirLight.shadow.camera.top = 30;
            dirLight.shadow.camera.bottom = -30;
            dirLight.shadow.bias = -0.0005;
            scene.add(dirLight);

            ground = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            gridHelper = new THREE.GridHelper(200, 100, 0x000000, 0x404040);
            gridHelper.position.y = 0.01;
            gridHelper.material.opacity = 0.5;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            envGroup = new THREE.Group();
            scene.add(envGroup);

            regenerateEnvironment(12345);

            window.addEventListener('resize', onWindowResize, false);
            
            onWindowResize();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            if (isRendering) return;

            let targetAspect = window.innerWidth / window.innerHeight;
            if (config.width && config.height) {
                targetAspect = config.width / config.height;
            }

            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const windowAspect = windowWidth / windowHeight;

            let finalWidth, finalHeight;

            if (windowAspect > targetAspect) {
                finalHeight = windowHeight;
                finalWidth = finalHeight * targetAspect;
            } else {
                finalWidth = windowWidth;
                finalHeight = finalWidth / targetAspect;
            }

            camera.aspect = targetAspect; 
            camera.updateProjectionMatrix();
            renderer.setSize(finalWidth, finalHeight);
        }

        function regenerateEnvironment(seed) {
            while(envGroup.children.length > 0){ 
                const obj = envGroup.children[0];
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) obj.material.dispose();
                envGroup.remove(obj); 
            }

            const rand = mulberry32(seed); 
            const distMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.9 });
            
            for (let i = 0; i < 40; i++) {
                const s = rand() * 5 + 2; 
                const angle = rand() * Math.PI * 2;
                const dist = 60 * (0.2 + rand() * 0.8); 
                
                const box = new THREE.Mesh(new THREE.BoxGeometry(s, s, s), distMat);
                box.position.set(Math.cos(angle) * dist, s / 2, Math.sin(angle) * dist);
                box.castShadow = true;
                box.receiveShadow = true;
                envGroup.add(box);
            }
            
            const pillarGeo = new THREE.BoxGeometry(1, 10, 1);
            const pillarMat = new THREE.MeshStandardMaterial({color: 0xff5555});
            [[-15, -15], [15, 15], [-15, 15], [15, -15]].forEach(pos => {
                const p = new THREE.Mesh(pillarGeo, pillarMat);
                p.position.set(pos[0], 5, pos[1]);
                p.castShadow = true;
                p.receiveShadow = true;
                envGroup.add(p);
            });
        }

        function setupEnvironment(cfg) {
            const type = cfg.skyboxType || "None (Gray)";
            gridHelper.visible = true; 

            if (type === "Texture Skybox (Folder)") {
                const loader = new THREE.CubeTextureLoader();
                loader.setPath(SKYBOX_PATH);
                loader.load(
                    ['px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'],
                    (texture) => {
                        scene.background = texture;
                        scene.environment = texture;
                        scene.fog = null;
                        document.getElementById('status').innerText = "Skybox loaded.";
                        renderer.render(scene, camera);
                    },
                    undefined,
                    () => { scene.background = new THREE.Color(0x444444); }
                );
            } else if (type === "Simple Sky (Blue)") {
                scene.background = new THREE.Color(0x87CEEB);
                scene.environment = null;
                scene.fog = new THREE.Fog(0x87CEEB, 20, 100);
            } else {
                scene.background = new THREE.Color(0x444444);
                scene.environment = null;
                scene.fog = null;
            }
        }

        async function setupFigure(cfg) {
            if (figureGroup) scene.remove(figureGroup);
            figureGroup = new THREE.Group();
            scene.add(figureGroup);

            if (cfg.modelUrl && cfg.modelUrl.length > 5 && cfg.modelUrl !== "none") {
                document.getElementById('status').innerText = "Loading external model...";
                try {
                    const loader = new GLTFLoader();
                    const gltf = await loader.loadAsync(cfg.modelUrl);
                    const model = gltf.scene;
                    
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scaleFactor = (2.0 / maxDim) * (cfg.scale || 1.0);
                    
                    model.scale.setScalar(scaleFactor);
                    
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    
                    model.position.x = -center.x * scaleFactor;
                    model.position.y = -box.min.y * scaleFactor; 
                    model.position.z = -center.z * scaleFactor;

                    model.traverse(o => {
                        if (o.isMesh) {
                            o.castShadow = true;
                            o.receiveShadow = true;
                        }
                    });
                    
                    figureGroup.add(model);
                    document.getElementById('status').innerText = "Model loaded.";
                    return; 
                } catch (e) {
                    console.error("Failed to load model", e);
                    document.getElementById('status').innerText = "Model load failed, using default.";
                }
            }
            createProceduralFigure(cfg);
        }

        function createProceduralFigure(cfg) {
            const scale = cfg.scale || 1.0;
            const limbLen = (cfg.limbLength || 0.6) * scale;
            const headR = baseFigureHeadRadius * scale;
            const bodyH = baseFigureBodyHeight * scale;
            const bodyW = 0.5 * scale;
            const bodyD = 0.25 * scale;
            const limbR = 0.08 * scale;

            const matYellow = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.5 });
            const matGreen = new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.6 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.6 });
            const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111 });

            const legCenterY = limbLen / 2;
            const bodyCenterY = limbLen + bodyH / 2;
            const headCenterY = limbLen + bodyH + headR;

            const head = new THREE.Mesh(new THREE.SphereGeometry(headR, 32, 16), matYellow);
            head.position.y = headCenterY;
            head.castShadow = true;
            figureGroup.add(head);

            if (cfg.showFace) {
                const eyeGeo = new THREE.SphereGeometry(headR * 0.15, 8, 8);
                const leftEye = new THREE.Mesh(eyeGeo, matBlack);
                leftEye.position.set(-headR*0.35, headR*0.15, headR*0.85);
                head.add(leftEye);
                const rightEye = leftEye.clone();
                rightEye.position.x = -leftEye.position.x;
                head.add(rightEye);
                const mouth = new THREE.Mesh(new THREE.BoxGeometry(headR*0.5, headR*0.1, headR*0.1), matBlack);
                mouth.position.set(0, -headR*0.3, headR*0.85);
                head.add(mouth);
            }

            const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyD), matGreen);
            body.position.y = bodyCenterY;
            body.castShadow = true;
            figureGroup.add(body);

            const limbGeo = new THREE.CylinderGeometry(limbR, limbR, limbLen, 12);
            const armY = bodyCenterY + bodyH/2 - limbR; 
            const armX = bodyW / 2 + limbR;
            
            const leftArm = new THREE.Mesh(limbGeo, matRed);
            leftArm.position.set(-armX, armY - limbLen/2, 0);
            leftArm.castShadow = true;
            figureGroup.add(leftArm);

            const rightArm = new THREE.Mesh(limbGeo, matRed);
            rightArm.position.set(armX, armY - limbLen/2, 0);
            rightArm.castShadow = true;
            figureGroup.add(rightArm);

            const legX = bodyW / 4;
            const leftLeg = new THREE.Mesh(limbGeo, matRed);
            leftLeg.position.set(-legX, legCenterY, 0);
            leftLeg.castShadow = true;
            figureGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(limbGeo, matRed);
            rightLeg.position.set(legX, legCenterY, 0);
            rightLeg.castShadow = true;
            figureGroup.add(rightLeg);
        }

        // --- [核心修改] 状态计算逻辑 (支持状态保持) ---
        function calculateFrameState(frame, cfg) {
            // 初始值 (基准)
            let state = {
                figX: 0, figY: 0, figZ: 0, figRot: 0, 
                dist: cfg.initialDistance,
                elev: cfg.initialElevationDeg * (Math.PI / 180),
                azim: cfg.initialAzimuthDeg * (Math.PI / 180),
                panX: 0, panY: 0,
                fov: cfg.fov,
                roll: 0
            };

            const applySegments = (segments) => {
                if (!segments || segments.length === 0) return;
                
                // 1. 按开始帧排序，确保动作按时间顺序叠加
                // (使用 slice() 浅拷贝防止影响原始数据)
                const sorted = segments.slice().sort((a, b) => a.startFrame - b.startFrame);

                sorted.forEach(seg => {
                    let val = null;

                    // 逻辑A: 动作已结束 -> 保持结束值
                    if (frame >= seg.endFrame) {
                        val = seg.endValue;
                    } 
                    // 逻辑B: 动作进行中 -> 插值计算
                    else if (frame >= seg.startFrame) {
                        const len = seg.endFrame - seg.startFrame;
                        const progress = len === 0 ? 1 : (frame - seg.startFrame) / len;
                        const fn = EasingFunctions[seg.easing] || EasingFunctions.linear;
                        const t = fn(progress);
                        val = lerp(seg.startValue, seg.endValue, t);
                    }
                    // 逻辑C: 动作未开始 -> 不处理 (保留 state 中的旧值)

                    // 如果计算出了有效值，应用到 state
                    if (val !== null) {
                        switch (seg.type) {
                            case 'x_pos': state.figX = val; break;
                            case 'y_pos': state.figY = val; break;
                            case 'z_pos': state.figZ = val; break;
                            case 'rotation_y': state.figRot = val * (Math.PI / 180); break;
                            case 'distance': state.dist = val; break;
                            case 'panX': state.panX = val; break;
                            case 'panY': state.panY = val; break;
                            case 'fov': state.fov = val; break;
                            case 'elevation': state.elev = val * (Math.PI / 180); break;
                            case 'azimuth': state.azim = val * (Math.PI / 180); break;
                            case 'roll': state.roll = val * (Math.PI / 180); break;
                        }
                    }
                });
            };

            applySegments(cfg.figureSegments);
            applySegments(cfg.cameraSegments);
            return state;
        }

        function updateScene(state, cfg) {
            figureGroup.position.set(state.figX, state.figY, state.figZ);
            figureGroup.rotation.y = state.figRot;

            const followMode = cfg.cameraFollowMode || 'follow';
            const basePos = (followMode === 'follow') ? figureGroup.position.clone() : new THREE.Vector3(0, 0, 0);
            
            const defaultHeight = 1.0; 
            
            const lookAtTarget = new THREE.Vector3(
                basePos.x + state.panX,
                basePos.y + defaultHeight + (cfg.lookAtHeightOffset || 0) + state.panY,
                basePos.z
            );

            let elev = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, state.elev));
            let dist = Math.max(0.1, state.dist);

            const cx = lookAtTarget.x + dist * Math.cos(elev) * Math.sin(state.azim);
            const cy = lookAtTarget.y + dist * Math.sin(elev);
            const cz = lookAtTarget.z + dist * Math.cos(elev) * Math.cos(state.azim);

            camera.position.set(cx, cy, cz);
            
            if (camera.fov !== state.fov) {
                camera.fov = state.fov;
                camera.updateProjectionMatrix();
            }

            camera.up.set(0, 1, 0);
            camera.lookAt(lookAtTarget);
            
            if (state.roll !== 0) {
                const forward = new THREE.Vector3().subVectors(lookAtTarget, camera.position).normalize();
                camera.up.applyQuaternion(new THREE.Quaternion().setFromAxisAngle(forward, state.roll));
                camera.lookAt(lookAtTarget); 
            }
        }

        async function renderBatch(newConfig) {
            config = newConfig; 
            isRendering = true; 

            // 批量渲染时，严格设置为输出尺寸
            renderer.setSize(config.width, config.height);
            camera.aspect = config.width / config.height;
            camera.updateProjectionMatrix();

            const seed = config.seed !== undefined ? config.seed : Date.now();
            regenerateEnvironment(seed);

            setupEnvironment(config);
            await setupFigure(config);
            
            const statusEl = document.getElementById('status');
            statusEl.innerText = "Rendering...";

            const frames = [];
            const total = config.numFrames;

            for (let i = 0; i < total; i++) {
                const state = calculateFrameState(i, config);
                updateScene(state, config);
                renderer.render(scene, camera);
                
                const dataURL = renderer.domElement.toDataURL("image/png");
                frames.push(dataURL);
                
                if (i % 5 === 0) {
                    statusEl.innerText = `Rendering: ${i} / ${total}`;
                    await new Promise(r => setTimeout(r, 0));
                }
            }

            statusEl.innerText = "Uploading results...";
            window.parent.postMessage({
                type: "RENDER_RESULT",
                request_id: config.request_id,
                images: frames
            }, "*");
            
            statusEl.innerText = "Done. Preview Mode.";
            isRendering = false;
            
            // 渲染结束，恢复预览比例
            onWindowResize();
        }

        function startPreviewLoop() {
            if (isPreviewing) { 
                isPreviewing = false;
                cancelAnimationFrame(previewReqId);
                document.getElementById('status').innerText = "Preview Stopped.";
                return;
            }

            if (!config.numFrames) {
                document.getElementById('status').innerText = "Run prompt first to load config.";
                return;
            }

            isPreviewing = true;
            isRendering = false;
            
            // 开始预览时，根据配置和当前窗口重新计算尺寸
            onWindowResize();

            const seed = config.seed !== undefined ? config.seed : 12345;
            regenerateEnvironment(seed);
            setupEnvironment(config);
            setupFigure(config);

            let frame = 0;
            
            function loop() {
                if (!isPreviewing) return;
                const state = calculateFrameState(frame, config);
                updateScene(state, config);
                renderer.render(scene, camera);
                document.getElementById('status').innerText = `Preview Frame: ${frame}`;
                frame++;
                if (frame >= config.numFrames) frame = 0;
                setTimeout(() => {
                    previewReqId = requestAnimationFrame(loop);
                }, 1000 / (config.fps || 30));
            }
            loop();
        }

        window.addEventListener('message', (event) => {
            const data = event.data;
            if (data.type === "RENDER_BATCH") {
                isPreviewing = false;
                cancelAnimationFrame(previewReqId);
                renderBatch(data.config);
            } else if (data.type === "START_PREVIEW") {
                if (data.config) config = data.config;
                startPreviewLoop(); 
            }
        });

        init();

    </script>
</body>
</html>