<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #111; 
            color: #fff; 
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }
        canvas { 
            display: block; 
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        #status {
            position: absolute; bottom: 10px; left: 10px; 
            background: rgba(0,0,0,0.7); padding: 5px 10px; border-radius: 4px;
            font-size: 12px; pointer-events: none; z-index: 10;
        }
    </style>
</head>
<body>
    <div id="status">Waiting for config...</div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // === 全局变量 ===
        let scene, camera, renderer, figureGroup, ground, gridHelper, envGroup;
        let ambientLight, dirLight;
        let config = {}; 
        let isPreviewing = false;
        let isRendering = false;
        let previewReqId;
        
        let skinnedMesh, skeleton;
        let modelDataCache = null;

        const SKYBOX_PATH = "./textures/skybox/"; 
        const ASSETS_PATH = "./assets/wooden"; 

        // === 工具函数 ===
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        const EasingFunctions = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => t * (2 - t),
            easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (--t) * t * t + 1,
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
        };
        const lerp = (a, b, t) => a * (1 - t) + b * t;

        // === 资源加载 ===
        async function fetchBinary(fileName) {
            const url = `${ASSETS_PATH}/${fileName}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Failed to load ${fileName}: ${response.status}`);
            return await response.arrayBuffer();
        }

        async function fetchJson(fileName) {
            const url = `${ASSETS_PATH}/${fileName}`;
            try {
                const response = await fetch(url);
                if (response.ok) return await response.json();
            } catch (e) {}
            return null;
        }

        async function loadModelData() {
            if (modelDataCache) return modelDataCache;
            document.getElementById('status').innerText = "Downloading wooden assets...";
            try {
                const [v_buf, j_buf, w_buf, i_buf, k_buf, f_buf, j_names] = await Promise.all([
                    fetchBinary('v_template.bin'),
                    fetchBinary('j_template.bin'),
                    fetchBinary('skinWeights.bin'),
                    fetchBinary('skinIndice.bin'),
                    fetchBinary('kintree.bin'),
                    fetchBinary('faces.bin'),
                    fetchJson('joint_names.json')
                ]);

                modelDataCache = {
                    vertices: new Float32Array(v_buf),
                    joints: new Float32Array(j_buf),
                    weights: new Float32Array(w_buf),
                    indices: new Uint16Array(i_buf),
                    parents: new Int32Array(k_buf),
                    faces: new Uint16Array(f_buf),
                    jointNames: j_names || []
                };
                return modelDataCache;
            } catch (e) {
                console.error("Model load error:", e);
                return null;
            }
        }

        function buildSkeleton(joints, parents, jointNames) {
            const numJoints = joints.length / 3;
            const bones = [];
            for (let i = 0; i < numJoints; i++) {
                const bone = new THREE.Bone();
                bone.name = (jointNames && jointNames[i]) ? jointNames[i] : `joint_${i}`;
                bones.push(bone);
            }
            for (let i = 0; i < numJoints; i++) {
                const parentIdx = parents[i];
                const pos = new THREE.Vector3(joints[i * 3], joints[i * 3 + 1], joints[i * 3 + 2]);
                if (parentIdx >= 0 && parentIdx < numJoints) {
                    bones[parentIdx].add(bones[i]);
                    pos.sub(new THREE.Vector3(joints[parentIdx * 3], joints[parentIdx * 3 + 1], joints[parentIdx * 3 + 2]));
                }
                bones[i].position.copy(pos);
            }
            return new THREE.Skeleton(bones);
        }

        // === 初始化 ===

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(0, 0); 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(10, 30, 20);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            const d = 50;
            dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
            dirLight.shadow.bias = -0.0005;
            scene.add(dirLight);

            ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8 }));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            gridHelper = new THREE.GridHelper(200, 100, 0x000000, 0x404040);
            gridHelper.position.y = 0.01;
            gridHelper.material.transparent = true;
            gridHelper.material.opacity = 0.5;
            scene.add(gridHelper);

            envGroup = new THREE.Group();
            scene.add(envGroup);
            figureGroup = new THREE.Group();
            scene.add(figureGroup);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            if (isRendering) return;
            const targetWidth = config.width || 512;
            const targetHeight = config.height || 512;
            const targetAspect = targetWidth / targetHeight;

            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const windowAspect = windowWidth / windowHeight;

            let finalWidth, finalHeight;
            if (windowAspect > targetAspect) {
                finalHeight = windowHeight;
                finalWidth = finalHeight * targetAspect;
            } else {
                finalWidth = windowWidth;
                finalHeight = finalWidth / targetAspect;
            }
            renderer.setSize(finalWidth, finalHeight);
            camera.aspect = targetAspect;
            camera.updateProjectionMatrix();
        }

        function regenerateEnvironment(seed) {
            while(envGroup.children.length > 0){ 
                const obj = envGroup.children[0];
                if(obj.geometry) obj.geometry.dispose();
                if(obj.material) obj.material.dispose();
                envGroup.remove(obj); 
            }
            const rand = mulberry32(seed); 
            const distMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.9 });
            for (let i = 0; i < 40; i++) {
                const s = rand() * 5 + 2; 
                const angle = rand() * Math.PI * 2;
                const dist = 60 * (0.2 + rand() * 0.8); 
                const box = new THREE.Mesh(new THREE.BoxGeometry(s, s, s), distMat);
                box.position.set(Math.cos(angle) * dist, s / 2, Math.sin(angle) * dist);
                box.castShadow = true; box.receiveShadow = true;
                envGroup.add(box);
            }
            const pillarGeo = new THREE.BoxGeometry(1, 10, 1);
            const pillarMat = new THREE.MeshStandardMaterial({color: 0xff5555});
            [[-15, -15], [15, 15], [-15, 15], [15, -15]].forEach(pos => {
                const p = new THREE.Mesh(pillarGeo, pillarMat);
                p.position.set(pos[0], 5, pos[1]);
                p.castShadow = true; p.receiveShadow = true;
                envGroup.add(p);
            });
        }

        function setupEnvironment(cfg) {
            const type = cfg.skyboxType || "None (Gray)";
            if (type === "Texture Skybox (Folder)") {
                const loader = new THREE.CubeTextureLoader();
                loader.setPath(SKYBOX_PATH);
                loader.load(['px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png'],
                    (texture) => { scene.background = texture; scene.environment = texture; scene.fog = null; },
                    undefined, () => { scene.background = new THREE.Color(0x444444); }
                );
            } else if (type === "Simple Sky (Blue)") {
                scene.background = new THREE.Color(0x87CEEB);
                scene.environment = null;
                scene.fog = new THREE.Fog(0x87CEEB, 20, 100);
            } else {
                scene.background = new THREE.Color(0x444444);
                scene.environment = null;
                scene.fog = null;
            }
        }

        // === 人物设置 ===
        async function setupFigure(cfg) {
            while(figureGroup.children.length > 0) figureGroup.remove(figureGroup.children[0]); 
            skinnedMesh = null;
            skeleton = null;

            const type = cfg.figureType || "blocky";

            // 1. Wooden Boy
            if (type === "wooden") {
                const data = await loadModelData();
                if (data) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(data.vertices, 3));
                    geometry.setIndex(new THREE.BufferAttribute(data.faces, 1));
                    geometry.setAttribute('skinWeight', new THREE.BufferAttribute(data.weights, 4));
                    geometry.setAttribute('skinIndex', new THREE.BufferAttribute(data.indices, 4));
                    geometry.computeVertexNormals();
                    const mat = new THREE.MeshStandardMaterial({ color: 0xccaa88, metalness: 0.1, roughness: 0.6, side: THREE.DoubleSide });
                    skeleton = buildSkeleton(data.joints, data.parents, data.jointNames);
                    skinnedMesh = new THREE.SkinnedMesh(geometry, mat);
                    skinnedMesh.add(skeleton.bones[0]);
                    skinnedMesh.bind(skeleton);
                    skinnedMesh.castShadow = true;
                    skinnedMesh.receiveShadow = true;
                    skinnedMesh.scale.setScalar(cfg.scale || 1.0);
                    figureGroup.add(skinnedMesh);
                    document.getElementById('status').innerText = "Wooden Figure Loaded";
                    return;
                } else {
                    console.warn("Failed to load wooden assets, falling back to blocky.");
                }
            }

            // 2. Custom GLB
            if (type === "custom" && cfg.modelUrl && cfg.modelUrl !== "none") {
                document.getElementById('status').innerText = "Loading GLB...";
                try {
                    const loader = new GLTFLoader();
                    const gltf = await loader.loadAsync(cfg.modelUrl);
                    const model = gltf.scene;
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scaleFactor = (1.8 / maxDim) * (cfg.scale || 1.0);
                    model.scale.setScalar(scaleFactor);
                    const center = new THREE.Vector3(); box.getCenter(center);
                    model.position.x = -center.x * scaleFactor;
                    model.position.y = -box.min.y * scaleFactor;
                    model.position.z = -center.z * scaleFactor;
                    model.traverse(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; }});
                    figureGroup.add(model);
                    document.getElementById('status').innerText = "GLB Loaded";
                    return;
                } catch (e) {
                    console.error("GLB load failed", e);
                }
            }

            // 3. Blocky (Default) - 恢复细节逻辑
            createProceduralFigure(cfg);
            document.getElementById('status').innerText = "Blocky Figure Loaded";
        }

        // --- 修复后的 createProceduralFigure (包含五官和四肢) ---
        function createProceduralFigure(cfg) {
            const scale = cfg.scale || 1.0;
            
            // 基础尺寸参数
            const baseHeadR = 0.25;
            const baseBodyH = 0.7;
            const baseBodyW = 0.5;
            const baseLimbR = 0.08;
            const baseLimbLen = cfg.limbLength || 0.6;

            // 应用缩放
            const headR = baseHeadR * scale;
            const bodyH = baseBodyH * scale;
            const bodyW = baseBodyW * scale;
            const bodyD = 0.25 * scale;
            const limbR = baseLimbR * scale;
            const limbLen = baseLimbLen * scale;

            const matYellow = new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.5 });
            const matGreen = new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.6 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.6 });
            const matBlack = new THREE.MeshStandardMaterial({ color: 0x111111 });

            // 计算位置
            const legCenterY = limbLen / 2;
            const bodyCenterY = limbLen + bodyH / 2;
            const headCenterY = limbLen + bodyH + headR;

            // 1. 头部
            const head = new THREE.Mesh(new THREE.SphereGeometry(headR, 32, 16), matYellow);
            head.position.y = headCenterY;
            head.castShadow = true;
            figureGroup.add(head);

            // 2. 五官
            if (cfg.showFace !== false) {
                const eyeGeo = new THREE.SphereGeometry(headR * 0.15, 8, 8);
                const leftEye = new THREE.Mesh(eyeGeo, matBlack);
                leftEye.position.set(-headR * 0.35, headR * 0.15, headR * 0.85);
                head.add(leftEye);
                const rightEye = leftEye.clone();
                rightEye.position.x = -leftEye.position.x;
                head.add(rightEye);
                const mouth = new THREE.Mesh(new THREE.BoxGeometry(headR * 0.5, headR * 0.1, headR * 0.1), matBlack);
                mouth.position.set(0, -headR * 0.3, headR * 0.85);
                head.add(mouth);
            }

            // 3. 身体
            const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyD), matGreen);
            body.position.y = bodyCenterY;
            body.castShadow = true;
            figureGroup.add(body);

            // 4. 四肢
            const limbGeo = new THREE.CylinderGeometry(limbR, limbR, limbLen, 12);
            
            const armY = bodyCenterY + bodyH / 2 - limbR; 
            const armX = bodyW / 2 + limbR;
            
            const leftArm = new THREE.Mesh(limbGeo, matRed);
            leftArm.position.set(-armX, armY - limbLen / 2, 0);
            leftArm.castShadow = true;
            figureGroup.add(leftArm);

            const rightArm = new THREE.Mesh(limbGeo, matRed);
            rightArm.position.set(armX, armY - limbLen / 2, 0);
            rightArm.castShadow = true;
            figureGroup.add(rightArm);

            const legX = bodyW / 4;
            const leftLeg = new THREE.Mesh(limbGeo, matRed);
            leftLeg.position.set(-legX, legCenterY, 0);
            leftLeg.castShadow = true;
            figureGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(limbGeo, matRed);
            rightLeg.position.set(legX, legCenterY, 0);
            rightLeg.castShadow = true;
            figureGroup.add(rightLeg);
        }

        // === 动画计算 ===

        function calculateFrameState(frame, cfg) {
            let state = {
                figX: 0, figY: 0, figZ: 0, figRot: 0, 
                dist: cfg.initialDistance || 7.0, elev: (cfg.initialElevationDeg||10)*(Math.PI/180), azim: (cfg.initialAzimuthDeg||0)*(Math.PI/180),
                panX: 0, panY: 0, fov: cfg.fov || 50, roll: 0
            };
            const applySegments = (segments) => {
                if (!segments) return;
                const sorted = segments.slice().sort((a, b) => a.startFrame - b.startFrame);
                sorted.forEach(seg => {
                    let val = null;
                    if (frame >= seg.endFrame) val = seg.endValue;
                    else if (frame >= seg.startFrame) {
                        const t = EasingFunctions[seg.easing || 'linear']((frame - seg.startFrame)/(seg.endFrame - seg.startFrame));
                        val = lerp(seg.startValue, seg.endValue, t);
                    }
                    if (val !== null) {
                         if(seg.type === 'x_pos') state.figX = val;
                         if(seg.type === 'y_pos') state.figY = val;
                         if(seg.type === 'z_pos') state.figZ = val;
                         if(seg.type === 'rotation_y') state.figRot = val * (Math.PI/180);
                         if(seg.type === 'distance') state.dist = val;
                         if(seg.type === 'elevation') state.elev = val * (Math.PI/180);
                         if(seg.type === 'azimuth') state.azim = val * (Math.PI/180);
                         if(seg.type === 'panX') state.panX = val;
                         if(seg.type === 'panY') state.panY = val;
                         if(seg.type === 'fov') state.fov = val;
                         if(seg.type === 'roll') state.roll = val * (Math.PI/180);
                    }
                });
            };
            applySegments(cfg.figureSegments);
            applySegments(cfg.cameraSegments);
            return state;
        }

        function updateScene(state, cfg, frame) {
            figureGroup.position.set(state.figX, state.figY, state.figZ);
            figureGroup.rotation.y = state.figRot;

            if (cfg.figureType === "wooden" && skeleton && cfg.motionData && cfg.motionData.enabled) {
                const md = cfg.motionData;
                // 动作钳制：超过最大帧数保持最后一帧
                const motionFrame = Math.min(frame, md.num_frames - 1);
                
                const offsetBase = motionFrame * md.num_joints * 4;
                const quats = md.quaternions;
                const transl = md.transl;

                const tOff = motionFrame * 3;
                skeleton.bones[0].position.set(transl[tOff], transl[tOff+1], transl[tOff+2]);

                for (let j = 0; j < md.num_joints; j++) {
                    if (j >= skeleton.bones.length) break;
                    const o = offsetBase + j * 4;
                    skeleton.bones[j].quaternion.set(quats[o+1], quats[o+2], quats[o+3], quats[o]);
                }
            }

            const defaultHeight = 1.0;
            const followMode = cfg.cameraFollowMode || 'follow';
            const basePos = (followMode === 'follow') ? figureGroup.position.clone() : new THREE.Vector3(0, 0, 0);

            const lookAtTarget = new THREE.Vector3(
                basePos.x + state.panX,
                basePos.y + defaultHeight + (cfg.lookAtHeightOffset || 0) + state.panY,
                basePos.z
            );

            let elev = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, state.elev));
            let dist = Math.max(0.1, state.dist);

            const cx = lookAtTarget.x + dist * Math.cos(elev) * Math.sin(state.azim);
            const cy = lookAtTarget.y + dist * Math.sin(elev);
            const cz = lookAtTarget.z + dist * Math.cos(elev) * Math.cos(state.azim);

            camera.position.set(cx, cy, cz);
            if (camera.fov !== state.fov) {
                camera.fov = state.fov;
                camera.updateProjectionMatrix();
            }
            camera.up.set(0, 1, 0);
            camera.lookAt(lookAtTarget);

            if (state.roll !== 0) {
                const forward = new THREE.Vector3().subVectors(lookAtTarget, camera.position).normalize();
                camera.up.applyQuaternion(new THREE.Quaternion().setFromAxisAngle(forward, state.roll));
                camera.lookAt(lookAtTarget);
            }
        }

        async function renderBatch(newConfig) {
            config = newConfig; 
            isRendering = true; 
            renderer.setSize(config.width, config.height);
            camera.aspect = config.width / config.height;
            camera.updateProjectionMatrix();

            const seed = config.seed !== undefined ? config.seed : Date.now();
            regenerateEnvironment(seed);
            setupEnvironment(config);
            await setupFigure(config); 

            const frames = [];
            const total = config.numFrames;
            document.getElementById('status').innerText = "Rendering...";

            for (let i = 0; i < total; i++) {
                const state = calculateFrameState(i, config);
                updateScene(state, config, i);
                renderer.render(scene, camera);
                frames.push(renderer.domElement.toDataURL("image/png"));
                if (i % 5 === 0) await new Promise(r => setTimeout(r, 0));
            }

            window.parent.postMessage({ type: "RENDER_RESULT", request_id: config.request_id, images: frames }, "*");
            isRendering = false;
            onWindowResize();
            document.getElementById('status').innerText = "Done. Preview Mode.";
        }

        function startPreviewLoop() {
            if (isPreviewing) { 
                isPreviewing = false;
                cancelAnimationFrame(previewReqId);
                document.getElementById('status').innerText = "Preview Stopped.";
                return;
            }
            if (!config.numFrames) {
                document.getElementById('status').innerText = "No config found.";
                return;
            }
            isPreviewing = true;
            isRendering = false;
            onWindowResize();

            const seed = config.seed !== undefined ? config.seed : 12345;
            regenerateEnvironment(seed);
            setupEnvironment(config);
            
            setupFigure(config).then(() => {
                let frame = 0;
                function loop() {
                    if (!isPreviewing) return;
                    const state = calculateFrameState(frame, config);
                    updateScene(state, config, frame);
                    renderer.render(scene, camera);
                    document.getElementById('status').innerText = `Preview: ${frame}/${config.numFrames}`;
                    
                    frame++;
                    if (frame >= config.numFrames) frame = 0;
                    setTimeout(() => { previewReqId = requestAnimationFrame(loop); }, 1000 / (config.fps || 30));
                }
                loop();
            });
        }

        window.addEventListener('message', (event) => {
            if (event.data.type === "RENDER_BATCH") renderBatch(event.data.config);
            if (event.data.type === "START_PREVIEW") { config = event.data.config; startPreviewLoop(); }
        });

        init();
    </script>
</body>
</html>